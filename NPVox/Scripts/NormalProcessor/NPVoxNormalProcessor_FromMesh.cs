using UnityEditor;using UnityEngine;using System;using System.Collections.Generic;using System.Linq;using System.Text;using MathUtilities;public class NPVoxNormalProcessorPass_FromMesh : NPVoxNormalProcessorPass{    public Mesh m_meshReference = null;    public Vector3 m_scaleVox = Vector3.zero;    public Vector3 m_scaleMesh = Vector3.zero;    public Vector3 m_offsetVox = Vector3.zero;    public Vector3 m_offsetMesh = Vector3.zero;    List<Vector3> m_meshVertices = new List<Vector3>();    List<Vector3> m_meshNormals = new List<Vector3>();    int[] m_triangleList = null;    public bool m_flipX = false;    public bool m_flipY = false;    public bool m_flipZ = false;    public int m_swapAxes = 0;    public bool m_dataAlreadyCollected = false;    public bool m_smoothNormals = false;    private void Swap<T>(int mode, ref T x, ref T y, ref T z)    {        T temp;        switch ( mode )        {            case 1: temp = x; x = y; y = temp; break;            case 2: temp = y; y = z; z = temp; break;            case 3: temp = z; z = x; x = temp; break;            default: break;        }    }    private void Swap(int mode, ref Vector3 v)    {        float x = v.x;        float y = v.y;        float z = v.z;        Swap(mode, ref x, ref y, ref z);        v = new Vector3(x, y, z);    }    private void FlipPosition( bool flipX, bool flipY, bool flipZ, Vector3 bounds, ref Vector3 v )    {        float x = v.x;        float y = v.y;        float z = v.z;        if (flipX) { x = bounds.x - x; }        if (flipY) { y = bounds.y - y; }        if (flipZ) { z = bounds.z - z; }        v = new Vector3(x, y, z);    }    private void FlipNormal( bool flipX, bool flipY, bool flipZ, ref Vector3 n )    {        float x = n.x;        float y = n.y;        float z = n.z;        if (flipX) { x = x * -1; }        if (flipY) { y = y * -1; }        if (flipZ) { z = z * -1; }        n = new Vector3(x, y, z);    }    public void ComputeLocalOffset( NPVoxMeshData tempdata, out Vector3 result )    {        result = Vector3.zero;        if ( tempdata.hasBack ) { result += NPVoxCoord.BACK.ToVector3(); }        if (tempdata.hasLeft) { result += NPVoxCoord.LEFT.ToVector3(); }        if (tempdata.hasDown) { result += NPVoxCoord.DOWN.ToVector3(); }        if (tempdata.hasForward) { result += NPVoxCoord.FORWARD.ToVector3(); }        if (tempdata.hasRight) { result += NPVoxCoord.RIGHT.ToVector3(); }        if (tempdata.hasUp) { result += NPVoxCoord.UP.ToVector3(); }        result *= -0.5f;    }    public override void Process( NPVoxModel model, NPVoxMeshData tempdata, Vector3[] inNormals, ref Vector3[] outNormals )    {        if (m_meshReference != null && !tempdata.isHidden )        {            Vector3 sizeVoxel = tempdata.voxToUnity.VoxeSize;            if ( !m_dataAlreadyCollected )            {                Vector3 sizeVoxModel = model.BoundingBoxMinimal.Size.ToVector3();                Bounds boundsMesh = m_meshReference.bounds;                m_offsetVox = model.BoundingBoxMinimal.LeftDownBack.ToVector3();                m_offsetMesh = boundsMesh.min;                m_scaleVox = model.BoundingBoxMinimal.Size.ToVector3();                m_scaleMesh = new Vector3( boundsMesh.size.x, boundsMesh.size.y, boundsMesh.size.z );                                m_meshReference.GetNormals( m_meshNormals );                m_meshReference.GetVertices( m_meshVertices );                m_triangleList = m_meshReference.GetTriangles( 0 );                m_dataAlreadyCollected = true;                Swap<bool>(m_swapAxes, ref m_flipX, ref m_flipY, ref m_flipZ);            }            Vector3 localOffset;            ComputeLocalOffset(tempdata, out localOffset);            Vector3 x = tempdata.voxCoord.ToVector3() - m_offsetVox;
            //x += localOffset;            x += new Vector3(0.5f, 0.5f, 0.5f);            x = LinearAlgebra.DivideComponents(x, m_scaleVox);            Swap(m_swapAxes, ref x);            FlipPosition(m_flipX, m_flipY, m_flipZ, new Vector3( 1.0f, 1.0f, 1.0f ), ref x);            x = LinearAlgebra.MultiplyComponents(x, m_scaleMesh);            x += m_offsetMesh;                        int bestTriangle = -1;            float bestDistanceSquared = float.PositiveInfinity;            Vector3 bestNormal = Vector3.zero;            Vector3 bestPoint = Vector3.zero;            for ( int triangle = 0; triangle < m_triangleList.Length; triangle += 3 )            {                Vector3 v1 = m_meshVertices[ m_triangleList[ triangle + 0 ] ];                Vector3 v2 = m_meshVertices[ m_triangleList[ triangle + 1 ] ];                Vector3 v3 = m_meshVertices[ m_triangleList[ triangle + 2 ] ];                                Vector3 n = LinearAlgebra.ComputePlaneNormal( v1, v2, v3 );                Vector3 xProjected;                LinearAlgebra.ProjectPointToPlane( v1, n, x, out xProjected );                Vector3 xBarycentric = LinearAlgebra.WorldToBarycentric3( v1, v2, v3, xProjected );                if ( xBarycentric.x < 0.0 )                {                     xProjected = LinearAlgebra.ClampToLine( v2, v3, xProjected );                }                else if ( xBarycentric.y < 0.0 )                {                    xProjected = LinearAlgebra.ClampToLine( v3, v1, xProjected );                }                else if ( xBarycentric.z < 0.0 )                {                    xProjected = LinearAlgebra.ClampToLine( v1, v2, xProjected );                }                float sqaredDistance = ( xProjected - x ).sqrMagnitude;                if ( !float.IsNaN( sqaredDistance ) && sqaredDistance < bestDistanceSquared )                {                    bestDistanceSquared = sqaredDistance;                    bestTriangle = triangle;                    bestNormal = n;                    bestPoint = xProjected;                }            }            Vector3 average = Vector3.zero;                        if ( bestTriangle != -1 )            {                if (m_smoothNormals)                {                    average = LinearAlgebra.BarycentricToWorld(                        m_meshNormals[ m_triangleList[ bestTriangle + 0 ] ],                        m_meshNormals[ m_triangleList[ bestTriangle + 1 ] ],                        m_meshNormals[ m_triangleList[ bestTriangle + 2 ] ],                        LinearAlgebra.WorldToBarycentric3(                            m_meshVertices[ m_triangleList[ bestTriangle + 0 ] ],                            m_meshVertices[ m_triangleList[ bestTriangle + 1 ] ],                            m_meshVertices[ m_triangleList[ bestTriangle + 2 ] ],                            bestPoint )                        );                }                else                {                    average = m_meshNormals[ m_triangleList[ bestTriangle ] ];                }                    average = LinearAlgebra.DivideComponents(average, m_scaleMesh);                FlipNormal(m_flipX, m_flipY, m_flipZ, ref average);                Swap(m_swapAxes, ref average);                average = LinearAlgebra.MultiplyComponents(average, m_scaleVox);                //Debug.Log("Computed normal for Coord" + tempdata.voxCoord.X + " " + tempdata.voxCoord.Y + " " + tempdata.voxCoord.Z + ": " + average.normalized.ToString() + " Triangle: " + bestTriangle);            }            for ( int t = 0; t < tempdata.numVertices; t++ )            {                outNormals[ tempdata.vertexIndexOffsetBegin + t ] = average;            }        }        else        {            for ( int t = 0; t < tempdata.numVertices; t++ )            {                outNormals[ tempdata.vertexIndexOffsetBegin + t ] = inNormals[ tempdata.vertexIndexOffsetBegin + t ];            }        }    }}[NPVoxAttributeNormalProcessorListItem( "From Mesh", typeof( NPVoxNormalProcessor_FromMesh ), NPVoxNormalProcessorType.Generator )]public class NPVoxNormalProcessor_FromMesh : NPVoxNormalProcessor{    [SerializeField]    private Mesh m_meshReference = null;    [SerializeField]    private bool m_smoothNormals;    [SerializeField]    private bool m_flipX;    [SerializeField]    private bool m_flipY;    [SerializeField]    private bool m_flipZ;    [SerializeField]    private int m_swapAxes;    private NPVoxNormalProcessorPass_FromMesh m_passFromMesh;    private NPVoxNormalProcessorPass_Normalize m_passNormalize;    public override object Clone()    {        NPVoxNormalProcessor_FromMesh clone = ScriptableObject.CreateInstance<NPVoxNormalProcessor_FromMesh>();        clone.m_meshReference = m_meshReference;        clone.m_smoothNormals = m_smoothNormals;        clone.m_flipX = m_flipX;        clone.m_flipY = m_flipY;        clone.m_flipZ = m_flipZ;        clone.m_swapAxes = m_swapAxes;        foreach ( int filter in m_voxelGroupFilter )        {            clone.m_voxelGroupFilter.Add( filter );        }        return clone;    }    protected override void OneTimeInit()    {        m_passFromMesh = AddPass<NPVoxNormalProcessorPass_FromMesh>();        m_passNormalize = AddPass<NPVoxNormalProcessorPass_Normalize>();    }    protected override void OnGUIInternal()    {        GUILayout.BeginHorizontal();        GUILayout.Space(GUITabWidth);        GUILayout.Label("Mesh Input");        EditorGUILayout.ObjectField( m_meshReference, typeof( Mesh ), false );        if ( GUILayout.Button( "Select" ) )        {            int controlID = EditorGUIUtility.GetControlID( FocusType.Passive );            EditorGUIUtility.ShowObjectPicker<Mesh>( m_meshReference, false, "", controlID );        }        string commandName = Event.current.commandName;        if ( commandName == "ObjectSelectorUpdated" )        {            m_meshReference = EditorGUIUtility.GetObjectPickerObject() as Mesh;        }        m_smoothNormals = GUILayout.Toggle(m_smoothNormals, "Smooth");        GUILayout.EndHorizontal();        GUILayout.BeginHorizontal();        GUILayout.Space(GUITabWidth);        GUILayout.Label("Swap Axes:");        string[] namesSwap = { "No", "X > Y", "Y > Z", "Z > X" };        m_swapAxes = EditorGUILayout.Popup(m_swapAxes, namesSwap);        GUILayout.Space(GUITabWidth);        GUILayout.Label("Flip:");        m_flipX = GUILayout.Toggle(m_flipX, "x", GUILayout.MaxWidth(40) );        m_flipY = GUILayout.Toggle(m_flipY, "y", GUILayout.MaxWidth(40) );        m_flipZ = GUILayout.Toggle(m_flipZ, "z", GUILayout.MaxWidth(40) );        GUILayout.EndHorizontal();    }    protected override void PerModelInit()    {        m_passFromMesh.m_meshReference = m_meshReference;        m_passFromMesh.m_dataAlreadyCollected = false;        m_passFromMesh.m_smoothNormals = m_smoothNormals;        m_passFromMesh.m_flipX = m_flipX;        m_passFromMesh.m_flipY = m_flipY;        m_passFromMesh.m_flipZ = m_flipZ;        m_passFromMesh.m_swapAxes = m_swapAxes;    }}